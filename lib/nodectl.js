// Generated by CoffeeScript 1.6.3
var NC, NODECTL, ROOTCTL, STDERR, STDOUT, cluster, coffee, fs, jade, markup, mkdirp, path, spawn, sqwish, stylus, uglify, util, _base;

fs = require('fs');

path = require('path');

util = require('util');

cluster = require('cluster');

spawn = require('child_process').spawn;

mkdirp = require('mkdirp');

coffee = require('coffee-script');

stylus = require('stylus');

jade = require('jade');

uglify = require('uglify-js');

sqwish = require('sqwish');

markup = require('html-minifier');

(_base = process.env).__nodectl || (_base.__nodectl = 'master');

NC = {};

STDOUT = fs.createWriteStream('/dev/null');

STDERR = fs.createWriteStream('/dev/null');

ROOTCTL = path.join(path.dirname(process.mainModule.filename), '..');

NODECTL = require(path.join(ROOTCTL, 'package.json'));

(function() {
  var dir, e, i, j, trace, _i, _j, _len, _len1, _ref, _ref1;
  NC.ROOTDIR = '/';
  _ref = process.cwd().split(path.sep);
  for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
    dir = _ref[i];
    trace = '';
    _ref1 = Array(i);
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      j = _ref1[_j];
      trace += ".." + path.sep;
    }
    if (fs.existsSync(path.resolve(trace, 'package.json'))) {
      NC.ROOTDIR = path.resolve(trace);
      break;
    }
  }
  NC.PKGINFO = {};
  NC.PKGINFO.PROJECT = (function() {
    try {
      return require(path.join(NC.ROOTDIR, 'package.json'));
    } catch (_error) {
      e = _error;
      return {};
    }
  })();
  NC.PKGINFO.RCNAMES = path.join(NC.ROOTDIR, NC.PKGINFO.PROJECT.nodectlrc || '.nodectl.json');
  NC.PKGINFO.NODECTL = (function() {
    try {
      return (function() {
        return JSON.parse(fs.readFileSync(NC.PKGINFO.RCNAMES, 'utf-8'));
      })();
    } catch (_error) {
      e = _error;
      return {};
    }
  })();
  NC.DEFAULT = function(key, val) {
    var NODE_ENV, k, v, _ref2;
    if (typeof NC.PKGINFO.NODECTL['switch_env'] !== 'undefined') {
      NODE_ENV = process.env.NODE_ENV || NC.PKGINFO.NODECTL['env'] || 'development';
      if (typeof NC.PKGINFO.NODECTL['switch_env'][NODE_ENV] !== 'undefined') {
        _ref2 = NC.PKGINFO.NODECTL['switch_env'][NODE_ENV];
        for (k in _ref2) {
          v = _ref2[k];
          if (k === key) {
            NC.PKGINFO.NODECTL[key] = v;
          }
        }
      }
    }
    return NC.PKGINFO.NODECTL[key] || NC.PKGINFO.PROJECT[key] || val;
  };
  NC.SYMBOLS = 'start';
  NC.ACTIONS = {
    start: true,
    stop: false,
    restart: false,
    status: false,
    debug: false,
    version: false,
    help: false
  };
  NC.OPTIONS = {
    port: NC.DEFAULT('port', 3000),
    env: NC.DEFAULT('env', 'development'),
    cluster: NC.DEFAULT('cluster', (require('os')).cpus().length),
    delay: NC.DEFAULT('delay', 250),
    exec: NC.DEFAULT('exec', ''),
    setenv: NC.DEFAULT('setenv', {}),
    log: NC.DEFAULT('log', ''),
    stdout: NC.DEFAULT('stdout', ''),
    stderr: NC.DEFAULT('stderr', ''),
    assets: NC.DEFAULT('assets', ''),
    output: NC.DEFAULT('output', ''),
    minify: NC.DEFAULT('minify', false),
    daemon: NC.DEFAULT('daemon', false),
    watch: NC.DEFAULT('watch', false),
    nocolor: NC.DEFAULT('nocolor', false)
  };
  NC.PROJECT = {
    name: NC.DEFAULT('name', false),
    main: NC.DEFAULT('main', false),
    version: NC.DEFAULT('version', false),
    running: path.join(NC.ROOTDIR, '.nodectl.run')
  };
  NC.PROCESS = {
    id: "" + NC.PROJECT.name + "/" + NC.PROJECT.version,
    pid: null,
    wid: [],
    xid: null
  };
  NC.DELETES = function() {
    NC.IMPORTS();
    try {
      process.kill(NC.PROCESS.pid, 'SIGINT');
      console.warn("" + NC.PROCESS.id + " stopped.");
    } catch (_error) {
      e = _error;
      console.error("ProcessError: " + e.message);
    }
    try {
      process.kill(NC.PROCESS.xid, 'SIGINT');
      return console.warn("" + NC.PROCESS.id + " exec process stopped.");
    } catch (_error) {
      e = _error;
      return console.warn("" + NC.PROCESS.id + " exec process already stopped.");
    } finally {
      if (fs.existsSync(NC.PROJECT.running)) {
        fs.unlinkSync(NC.PROJECT.running);
      }
    }
  };
  NC.EXPORTS = function() {
    try {
      if (NC.ACTIONS.debug) {
        return fs.writeFileSync(NC.PROJECT.running, JSON.stringify(NC, null, '  '));
      } else {
        return fs.writeFileSync(NC.PROJECT.running, JSON.stringify(NC));
      }
    } catch (_error) {
      e = _error;
      return console.error(e);
    } finally {
      return NC;
    }
  };
  NC.IMPORTS = function() {
    var json, k, v, _results;
    try {
      if (fs.existsSync(NC.PROJECT.running)) {
        json = JSON.parse(fs.readFileSync(NC.PROJECT.running, 'utf-8'));
        _results = [];
        for (k in json) {
          v = json[k];
          _results.push(NC[k] = v);
        }
        return _results;
      }
    } catch (_error) {
      e = _error;
      return console.error(e);
    } finally {
      return NC;
    }
  };
  if (fs.existsSync(NC.PROJECT.running)) {
    return NC.IMPORTS();
  }
})();

(function() {
  var ARGS, arg, e, envs, key, next, _i, _len, _ref;
  ARGS = [].concat(process.argv);
  ARGS.splice(0, 2);
  try {
    while (arg = ARGS.shift()) {
      if ('-' !== arg.substr(0, 1)) {
        switch (arg) {
          case 'start':
            NC.SYMBOLS = arg;
            NC.ACTIONS.start = true;
            NC.ACTIONS.stop = false;
            NC.ACTIONS.restart = false;
            NC.ACTIONS.status = false;
            break;
          case 'stop':
            NC.SYMBOLS = arg;
            NC.ACTIONS.start = false;
            NC.ACTIONS.stop = true;
            NC.ACTIONS.restart = false;
            NC.ACTIONS.status = false;
            break;
          case 'restart':
            NC.SYMBOLS = arg;
            NC.ACTIONS.start = false;
            NC.ACTIONS.stop = false;
            NC.ACTIONS.restart = true;
            NC.ACTIONS.status = false;
            break;
          case 'status':
            NC.SYMBOLS = arg;
            NC.ACTIONS.start = false;
            NC.ACTIONS.stop = false;
            NC.ACTIONS.restart = false;
            NC.ACTIONS.status = true;
            break;
          case 'version':
            NC.SYMBOLS = arg;
            NC.ACTIONS.version = true;
            break;
          case 'help':
            NC.SYMBOLS = arg;
            NC.ACTIONS.help = true;
            break;
          default:
            NC.PROJECT.main = arg;
            if (!fs.existsSync(NC.PROJECT.main)) {
              throw new Error("unrecognized action: " + arg);
            }
        }
      } else {
        switch (arg) {
          case '-p':
          case '-port':
          case '--port':
            if (typeof (next = ARGS.shift()) === 'undefined' || '-' === next.substr(0, 1)) {
              throw new Error("option '" + arg + "' requires parameter");
            }
            NC.OPTIONS.port = parseInt(next, 10);
            break;
          case '-e':
          case '-env':
          case '--env':
            if (typeof (next = ARGS.shift()) === 'undefined' || '-' === next.substr(0, 1)) {
              throw new Error("option '" + arg + "' requires parameter");
            }
            NC.OPTIONS.env = String(next);
            break;
          case '-c':
          case '-cluster':
          case '--cluster':
            if (typeof (next = ARGS.shift()) === 'undefined' || '-' === next.substr(0, 1)) {
              throw new Error("option '" + arg + "' requires parameter");
            }
            NC.OPTIONS.cluster = parseInt(next, 10);
            break;
          case '-d':
          case '-delay':
          case '--delay':
            if (typeof (next = ARGS.shift()) === 'undefined' || '-' === next.substr(0, 1)) {
              throw new Error("option '" + arg + "' requires parameter");
            }
            NC.OPTIONS.delay = parseInt(next, 10);
            break;
          case '-s':
          case '-setenv':
          case '--setenv':
            if (typeof (next = ARGS.shift()) === 'undefined' || '-' === next.substr(0, 1)) {
              throw new Error("option '" + arg + "' requires parameter");
            }
            envs = (String(next)).split('=');
            if (/^[1-9][0-9\.]*$/.test(envs[1])) {
              envs[1] = parseFloat(envs[1], 10);
            }
            NC.OPTIONS.setenv[envs[0]] = envs[1];
            break;
          case '-x':
          case '-exec':
          case '--exec':
            if (typeof (next = ARGS.shift()) === 'undefined' || '-' === next.substr(0, 1)) {
              throw new Error("option '" + arg + "' requires parameter");
            }
            NC.OPTIONS.exec = path.join(NC.ROOTDIR, next);
            break;
          case '-l':
          case '-log':
          case '--log':
            if (typeof (next = ARGS.shift()) === 'undefined' || '-' === next.substr(0, 1)) {
              throw new Error("option '" + arg + "' requires parameter");
            }
            NC.OPTIONS.log = path.join(NC.ROOTDIR, next);
            break;
          case '-1':
          case '-stdout':
          case '--stdout':
            if (typeof (next = ARGS.shift()) === 'undefined' || '-' === next.substr(0, 1)) {
              throw new Error("option '" + arg + "' requires parameter");
            }
            NC.OPTIONS.stdout = path.join(NC.ROOTDIR, next);
            break;
          case '-2':
          case '-stderr':
          case '--stderr':
            if (typeof (next = ARGS.shift()) === 'undefined' || '-' === next.substr(0, 1)) {
              throw new Error("option '" + arg + "' requires parameter");
            }
            NC.OPTIONS.stderr = path.join(NC.ROOTDIR, next);
            break;
          case '-a':
          case '-assets':
          case '--assets':
            if (typeof (next = ARGS.shift()) === 'undefined' || '-' === next.substr(0, 1)) {
              throw new Error("option '" + arg + "' requires parameter");
            }
            NC.OPTIONS.assets = path.join(NC.ROOTDIR, next);
            break;
          case '-o':
          case '-output':
          case '--output':
            if (typeof (next = ARGS.shift()) === 'undefined' || '-' === next.substr(0, 1)) {
              throw new Error("option '" + arg + "' requires parameter");
            }
            NC.OPTIONS.output = path.join(NC.ROOTDIR, next);
            break;
          case '-M':
          case '-minify':
          case '--minify':
            NC.OPTIONS.minify = true;
            break;
          case '-D':
          case '-daemon':
          case '--daemon':
            NC.OPTIONS.daemon = true;
            break;
          case '-W':
          case '-watch':
          case '--watch':
            NC.OPTIONS.watch = true;
            break;
          case '-N':
          case '-nocolor':
          case '--nocolor':
            NC.OPTIONS.nocolor = true;
            break;
          case '-v':
          case '-version':
          case '--version':
            NC.ACTIONS.version = true;
            break;
          case '-h':
          case '-help':
          case '--help':
            NC.ACTIONS.help = true;
            break;
          case '-debug':
          case '--debug':
            NC.ACTIONS.debug = true;
            break;
          default:
            throw new Error("unrecognized option: " + arg);
        }
      }
    }
    if (NC.OPTIONS.exec && '/' !== NC.OPTIONS.exec.substr(0, 1)) {
      NC.OPTIONS.exec = path.join(NC.ROOTDIR, NC.OPTIONS.exec);
    }
    _ref = ['log', 'stdout', 'stderr', 'assets', 'output'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      if (NC.OPTIONS[key] && '/' !== NC.OPTIONS[key].substr(0, 1)) {
        NC.OPTIONS[key] = path.join(NC.ROOTDIR, NC.OPTIONS[key]);
      }
      if ('/' === NC.OPTIONS[key].substr(-1)) {
        NC.OPTIONS[key] = NC.OPTIONS[key].substr(0, NC.OPTIONS[key].length - 1);
      }
    }
    if (!(NC.OPTIONS.setenv instanceof Object) && NC.OPTIONS.setenv.toString() !== '[object Object]') {
      envs = NC.OPTIONS.setenv.split('=');
      NC.OPTIONS.setenv = {};
      NC.OPTIONS.setenv[envs[0]] = envs[1];
    }
    if (isNaN(NC.OPTIONS.port)) {
      throw new Error("option '-p, port' parameter should number");
    }
    if (1 > NC.OPTIONS.env.length) {
      throw new Error("option '-e, env' parameter should string");
    }
    if (isNaN(NC.OPTIONS.cluster)) {
      throw new Error("option '-c, cluster' parameter should number");
    }
    if (isNaN(NC.OPTIONS.delay)) {
      throw new Error("option '-d, delay' parameter should number");
    }
    if (NC.OPTIONS.exec) {
      if (!fs.existsSync(NC.OPTIONS.exec || !(fs.statSync(NC.OPTIONS.exec)).isFile())) {
        throw new Error("option '-x, exec' parameter should file");
      }
    }
    if (NC.OPTIONS.log) {
      if (!fs.existsSync(path.dirname(NC.OPTIONS.log))) {
        mkdirp.sync(path.dirname(NC.OPTIONS.log));
      }
      if (!fs.existsSync(NC.OPTIONS.log)) {
        fs.writeFileSync(NC.OPTIONS.log, '');
      }
      if (!(fs.statSync(NC.OPTIONS.log)).isFile()) {
        throw new Error("option '-l, log' parameter should file");
      }
      NC.OPTIONS.stdout = NC.OPTIONS.stderr = NC.OPTIONS.log;
    }
    if (NC.OPTIONS.stdout) {
      if (!fs.existsSync(path.dirname(NC.OPTIONS.stdout))) {
        fs.mkdirSync(path.dirname(NC.OPTIONS.stdout));
      }
      if (!fs.existsSync(NC.OPTIONS.stdout)) {
        fs.writeFileSync(NC.OPTIONS.stdout, '');
      }
      if (!(fs.statSync(NC.OPTIONS.stdout)).isFile()) {
        throw new Error("option '-1, stdout' parameter should file");
      }
      STDOUT = fs.createWriteStream(NC.OPTIONS.stdout, {
        flags: 'a'
      });
    }
    if (NC.OPTIONS.stderr) {
      if (!fs.existsSync(path.dirname(NC.OPTIONS.stderr))) {
        fs.mkdirSync(path.dirname(NC.OPTIONS.stderr));
      }
      if (!fs.existsSync(NC.OPTIONS.stderr)) {
        fs.writeFileSync(NC.OPTIONS.stderr, '');
      }
      if (!(fs.statSync(NC.OPTIONS.stderr)).isFile()) {
        throw new Error("option '-2, stderr' parameter should file");
      }
      STDERR = fs.createWriteStream(NC.OPTIONS.stderr, {
        flags: 'a'
      });
    }
    if (NC.OPTIONS.assets) {
      if (!fs.existsSync(NC.OPTIONS.assets || !(fs.statSync(NC.OPTIONS.assets)).isDirectory())) {
        throw new Error("option '-a, assets' parameter should directory");
      }
      if (!NC.OPTIONS.output) {
        throw new Error("--assets requires --output");
      }
    }
    if (NC.OPTIONS.output) {
      if (!fs.existsSync(NC.OPTIONS.output || !(fs.statSync(NC.OPTIONS.output)).isDirectory())) {
        throw new Error("option '-o, output' parameter should directory");
      }
      if (!NC.OPTIONS.assets) {
        throw new Error("--output requires --assets");
      }
    }
  } catch (_error) {
    e = _error;
    console.error("\x1b[31mArgumentError: " + e.message + "\x1b[0m");
    return process.exit(1);
  } finally {
    process.env.PORT = NC.OPTIONS.port;
    process.env.NODE_ENV = NC.OPTIONS.env;
    process.env.NODECTL_NAME = NODECTL.name;
    process.env.NODECTL_VERSION = NODECTL.version;
    process.env.PROJECT_NAME = NC.PROJECT.name;
    process.env.PROJECT_VERSION = NC.PROJECT.version;
  }
})();

(function() {
  if (NC.ACTIONS.version || NC.ACTIONS.help) {
    console.log("nodectl version: " + NODECTL.name + "/" + NODECTL.version);
    if (NC.ACTIONS.help) {
      console.log("Usage: " + NODECTL.name + " [action] [options] <script>\n\nAction:\n  start   : start <script> as a node.js app\n  stop    : stop the <script>\n  restart : restart the <script>\n  status  : check the <program> running or not\n\nOptions:\n  -p, --port    : set process.env.PORT        " + process.env.PORT + "\n  -e, --env     : set process.env.NODE_ENV    " + process.env.NODE_ENV + "\n  -c, --cluster : number of concurrents       " + NC.OPTIONS.cluster + "\n  -d, --delay   : delay time for refork       " + NC.OPTIONS.delay + "\n  -s, --setenv  : set custom env (k=v)        " + ((util.inspect(NC.OPTIONS.setenv)).replace(/\n/g, '').replace(/\s\s*/g, ' ')) + "\n  -x, --exec    : exec job script             " + NC.OPTIONS.exec + "\n  -l, --log     : stdout+stderr log file      " + NC.OPTIONS.log + "\n  -1, --stdout  : stdout log file             " + NC.OPTIONS.stdout + "\n  -2, --stderr  : stderr log file             " + NC.OPTIONS.stderr + "\n  -a, --assets  : dir for assets              " + NC.OPTIONS.assets + "\n  -o, --output  : dir for assets output       " + NC.OPTIONS.output + "\n  -M, --minify  : minify compiled assets      " + NC.OPTIONS.minify + "\n  -D, --daemon  : daemonize process           " + NC.OPTIONS.daemon + "\n  -W, --watch   : restart app on code change  " + NC.OPTIONS.watch + "\n  -N, --nocolor : disable custom console      " + NC.OPTIONS.nocolor + "\n  -v, --version : show version and exit\n  -h, --help    : show this message and exit\n  --debug       : show debug information\n");
    }
    return process.exit(0);
  }
})();

(function() {
  var e;
  try {
    if (!NC.PROJECT.name) {
      throw new Error("application `name` unknown");
    }
    if (!NC.PROJECT.version) {
      throw new Error("application `version` unknown");
    }
    if (!NC.PROJECT.main) {
      throw new Error("application `main` script unknown");
    }
  } catch (_error) {
    e = _error;
    console.error("\x1b[31mProjectError: " + e.message + "\x1b[0m");
    console.error("\x1b[31mInformation must be described by package.json or " + (path.basename(NC.PKGINFO.RCNAMES)) + "\x1b[0m");
    return process.exit(1);
  }
})();

(function() {
  var _envkey, _envval, _ref, _results;
  if (NC.OPTIONS.setenv) {
    _ref = NC.OPTIONS.setenv;
    _results = [];
    for (_envkey in _ref) {
      _envval = _ref[_envkey];
      _results.push(process.env[_envkey] = _envval);
    }
    return _results;
  }
})();

(function() {
  var colorized, f, _i, _len, _ref, _results;
  console.debug = function() {
    var arg, i, msg, _i, _len;
    if (NC.ACTIONS.debug) {
      msg = '\x1b[37m';
      for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {
        arg = arguments[i];
        msg += typeof arg === 'string' ? arg : util.inspect(arg);
        if (arguments.length > i + 1) {
          msg += ' ';
        }
      }
      return util.print("" + msg + "\x1b[0m\n");
    }
  };
  if (!NC.OPTIONS.nocolor) {
    colorized = {};
    _ref = ['log', 'info', 'warn', 'error'];
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      f = _ref[_i];
      _results.push((function(f) {
        colorized[f] = console[f];
        return console[f] = function() {
          var msg;
          msg = (function() {
            switch (f) {
              case 'info':
                return '\x1b[34m';
              case 'warn':
                return '\x1b[33m';
              case 'error':
                return '\x1b[31m';
              default:
                return '\x1b[0m';
            }
          })();
          arguments[0] = "" + msg + arguments[0];
          return colorized[f].apply(this, arguments);
        };
      })(f));
    }
    return _results;
  }
})();

(function() {
  var trim, _stderr, _stdout;
  _stdout = process.stdout.write;
  _stderr = process.stdout.write;
  trim = function(str) {
    return str.replace(/^[ \n\r\t]+|[ \n\r\t]+$/g, '');
  };
  process.stdin.resume();
  process.stdout.write = function() {
    var head, i, msg, now, _i, _len, _ref;
    STDOUT.write(arguments[0].replace(/\x1b.*?m/g, ''));
    msg = (function() {
      switch (true) {
        case process.env.__nodectl === 'master':
          return '\x1b[32m';
        case /worker/.test(process.env.__nodectl):
          return '\x1b[33m';
        case process.env.__nodectl === 'exec':
          return '\x1b[34m';
        default:
          return '\x1b[35m';
      }
    })();
    now = new Date();
    now = "" + (('00' + now.getHours()).slice(-2)) + ":" + (('00' + now.getMinutes()).slice(-2)) + ":" + (('00' + now.getSeconds()).slice(-2));
    msg += head = now + ' ' + process.env.__nodectl;
    _ref = Array(20 - head.length);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      msg += ' ';
    }
    arguments[0] = "" + msg + "|\x1b[0m " + arguments[0];
    return _stdout.apply(this, arguments);
  };
  return process.stderr.write = function() {
    var head, i, msg, now, _i, _len, _ref;
    STDERR.write(arguments[0].replace(/\x1b.*?m/g, ''));
    msg = (function() {
      switch (true) {
        case process.env.__nodectl === 'master':
          return '\x1b[32m';
        case /worker/.test(process.env.__nodectl):
          return '\x1b[33m';
        case process.env.__nodectl === 'exec':
          return '\x1b[34m';
        default:
          return '\x1b[35m';
      }
    })();
    now = new Date();
    now = "" + (('00' + now.getHours()).slice(-2)) + ":" + (('00' + now.getMinutes()).slice(-2)) + ":" + (('00' + now.getSeconds()).slice(-2));
    msg += head = now + ' ' + process.env.__nodectl;
    _ref = Array(20 - head.length);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      msg += ' ';
    }
    arguments[0] = "" + msg + "|\x1b[0m " + arguments[0];
    return _stderr.apply(this, arguments);
  };
})();

(function() {
  process.stdout.pipe(STDOUT);
  process.stderr.pipe(STDERR);
  if (cluster.isMaster) {
    process.on('SIGINT', function() {
      console.debug('Master trap SIGINT');
      NC.DELETES();
      return process.exit(1);
    });
    process.on('nodectl:restart', function() {
      var i, wid, _i, _len, _ref, _results;
      console.debug("Restart all workers (delay: " + NC.OPTIONS.delay + " ms)");
      console.info("" + NC.PROCESS.id + " restart.");
      _ref = NC.PROCESS.wid;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        wid = _ref[i];
        _results.push((function(wid, i) {
          console.debug("Send SIGINT to #" + wid);
          return setTimeout(function() {
            var e;
            try {
              return process.kill(wid, 'SIGINT');
            } catch (_error) {
              e = _error;
              return console.error("ProcessError: " + e.message);
            }
          }, NC.OPTIONS.delay * i);
        })(wid, i));
      }
      return _results;
    });
    process.on('nodectl:rebuild', function(src, dst) {
      var code, e, f, i, len, line, lines, msg, startTime, tmp, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
      try {
        console.debug("Build assets < " + src);
        console.debug("Build assets > " + dst);
        startTime = new Date;
        if (!fs.exists(path.dirname(dst))) {
          mkdirp.sync(path.dirname(dst));
        }
        code = fs.readFileSync(src, 'utf-8');
        code = (function() {
          switch (path.extname(src)) {
            case '.coffee':
              return coffee.compile(code);
            case '.styl':
              return stylus(code).set('paths', [path.join(NC.ROOTDIR, 'node_modules'), path.dirname(src)]).define('url', stylus.url()).render();
            case '.jade':
              return jade.compile(code)();
            default:
              return code;
          }
        })();
        if (NC.OPTIONS.minify) {
          len = code.length;
          switch (path.extname(dst)) {
            case '.js':
              tmp = path.join('/tmp', new Date().toString());
              fs.writeFileSync(tmp, code);
              code = uglify.minify(tmp).code;
              fs.unlinkSync(tmp);
              break;
            case '.css':
              code = sqwish.minify(code);
              break;
            case '.html':
              code = markup.minify(code);
          }
          console.debug("Minified " + (parseInt(code.length / len * 1000) / 10) + " %");
        }
        console.debug("Elapsed time " + (new Date - startTime) + " ms");
        fs.writeFileSync(dst, code, 'utf-8');
        console.log("Build assets (" + (path.basename(src)) + " > " + (path.basename(dst)) + ")");
        return true;
      } catch (_error) {
        e = _error;
        console.error("Build assets failure. (" + src + ")");
        if (/\.coffee$/.test(src)) {
          lines = [];
          _ref = (fs.readFileSync(src, 'utf-8')).split('\n');
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            line = _ref[i];
            if (i + 1 > e.location.first_line - 5) {
              len || (len = (String(i + 1)).length + 2);
              if ((e.location.first_line <= (_ref1 = i + 1) && _ref1 <= e.location.last_line)) {
                msg = ' >';
                _ref2 = Array(len - (String(i + 1)).length);
                for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
                  f = _ref2[_j];
                  msg += ' ';
                }
              } else {
                msg = '  ';
                _ref3 = Array(len - (String(i + 1)).length);
                for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
                  f = _ref3[_k];
                  msg += ' ';
                }
              }
              lines.push("" + msg + (i + 1) + "| " + line);
            }
            if (i + 1 >= e.location.last_line + 3) {
              break;
            }
          }
          console.error("coffee:" + e.location.first_line + ":" + e.location.first_column + " " + e.message + "\n" + (lines.join('\n')));
        } else {
          console.error(e.message);
        }
        return false;
      }
    });
    if ((path.basename(NC.PKGINFO.RCNAMES)) !== '.nodectl.json') {
      console.debug("Using custom rc file name (" + (path.basename(NC.PKGINFO.RCNAMES)) + ")");
    }
    if (typeof NC.PKGINFO.NODECTL['switch_env'] !== 'undefined') {
      if (typeof NC.PKGINFO.NODECTL['switch_env'][process.env.NODE_ENV] !== 'undefined') {
        return console.debug("Using env switcher (" + process.env.NODE_ENV + ")");
      }
    }
  }
})();

(function() {
  if (NC.ACTIONS.status) {
    if (fs.existsSync(NC.PROJECT.running)) {
      util.print("" + NC.PROJECT.name + " running.\n");
    } else {
      util.print("" + NC.PROJECT.name + " not running.\n");
    }
    return process.exit(0);
  }
})();

(function() {
  var e;
  if (NC.ACTIONS.stop) {
    try {
      if (fs.existsSync(NC.PROJECT.running)) {
        return process.kill(NC.PROCESS.pid, 'SIGINT');
      } else {
        return console.warn("" + NC.PROCESS.id + " already stopped.");
      }
    } catch (_error) {
      e = _error;
      return console.error("" + e.message);
    } finally {
      if (fs.existsSync(NC.PROJECT.running)) {
        fs.unlinkSync(NC.PROJECT.running);
      }
      process.exit(0);
    }
  }
})();

(function() {
  if (NC.ACTIONS.restart) {
    return process.emit('nodectl:restart');
  }
})();

(function() {
  var args, bin, child, dir, e, k, seekdir, timeout, v, _fn, _fn1, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
  if (NC.ACTIONS.start) {
    if (cluster.isMaster) {
      if (fs.existsSync(NC.PROJECT.running)) {
        console.warn("" + NC.PROCESS.id + " already runninng");
        process.exit(1);
      }
      _ref = NC.ACTIONS;
      for (k in _ref) {
        v = _ref[k];
        console.debug('act', k, ':', v);
      }
      _ref1 = NC.OPTIONS;
      for (k in _ref1) {
        v = _ref1[k];
        console.debug('opt', k, ':', v);
      }
      console.info("" + NC.PROCESS.id + " starting.");
      NC.PROCESS.pid = process.pid;
      cluster.on('online', function(worker) {
        return console.log("Worker online #" + worker.process.pid);
      });
      cluster.on('listening', function(worker) {
        return console.info("Worker listening #" + worker.process.pid);
      });
      cluster.on('exit', function(worker) {
        var i, wid, _i, _len, _ref2, _worker;
        console.warn("Worker exit #" + worker.process.pid + " (" + (worker.suicide ? 'suicide' : 'no suicide') + ")");
        _ref2 = NC.PROCESS.wid;
        for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
          wid = _ref2[i];
          if (wid === worker.process.pid) {
            NC.PROCESS.wid.splice(i, 1);
            _worker = cluster.fork({
              __nodectl: worker.type
            });
            _worker.type = worker.type;
            NC.PROCESS.wid.push(_worker.process.pid);
          }
        }
        return NC.EXPORTS();
      });
      if (NC.OPTIONS.daemon) {
        if (!process.env.__daemon) {
          console.log("Master daemonize");
          args = [].concat(process.argv);
          args.shift();
          args.shift();
          process.env.__daemon = true;
          child = spawn(process.mainModule.filename, args, {
            stdio: 'ignore',
            env: process.env,
            cwd: process.cwd(),
            detached: true
          });
          child.unref();
          process.exit(0);
        }
        NC.PROCESS.pid = process.pid;
      }
      NC.EXPORTS();
      if (NC.OPTIONS.exec) {
        bin = (function() {
          switch (path.extname(NC.OPTIONS.exec)) {
            case '.coffee':
              return path.join(ROOTCTL, 'node_modules', 'coffee-script', 'bin', 'coffee');
            default:
              return 'node';
          }
        })();
        try {
          child = spawn(bin, [NC.OPTIONS.exec], {
            env: process.env,
            cwd: process.cwd(),
            detached: true
          });
          child.stdout.on('data', function(data) {
            var __pre;
            __pre = process.env.__nodectl;
            process.env.__nodectl = 'exec';
            util.print("" + data);
            return process.env.__nodectl = __pre;
          });
          child.stderr.on('data', function(data) {
            var __pre;
            __pre = process.env.__nodectl;
            process.env.__nodectl = 'exec';
            util.print("\x1b[31m" + data);
            return process.env.__nodectl = __pre;
          });
          console.log("Master spawn #" + child.pid);
          NC.PROCESS.xid = child.pid;
        } catch (_error) {
          e = _error;
          console.error(e);
        } finally {
          NC.EXPORTS();
        }
      }
      seekdir = function(dir) {
        var abs, rel, res, _i, _len, _ref2;
        res = [];
        if ((fs.statSync(dir)).isFile()) {
          return res;
        }
        _ref2 = fs.readdirSync(dir);
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          rel = _ref2[_i];
          abs = path.join(dir, rel);
          if (rel !== 'node_modules' && (rel.substr(0, 1)) !== '.') {
            if ((fs.statSync(abs)).isDirectory()) {
              res.push(abs);
              res = res.concat(arguments.callee(abs));
            }
          }
        }
        return res;
      };
      if (NC.OPTIONS.watch) {
        _ref2 = [NC.ROOTDIR].concat(seekdir(NC.ROOTDIR));
        _fn = function(dir) {
          var _this = this;
          if (NC.OPTIONS.assets && (new RegExp(NC.OPTIONS.assets)).test(dir)) {
            return null;
          }
          if (NC.OPTIONS.output && (new RegExp(NC.OPTIONS.output)).test(dir)) {
            return null;
          }
          console.log('Master watch', '<', dir);
          return fs.watch(dir, function(act, rel) {
            var timeout;
            console.debug("fs watch triggerd (" + act + ", " + rel + ")");
            if (/\.(js|coffee|json)$/.test(rel)) {
              clearTimeout(timeout);
              return timeout = setTimeout(function() {
                var abs;
                abs = path.join(dir, rel);
                if (act === 'change' || fs.existsSync(abs)) {
                  console.log("Code changed (" + rel + ")");
                  return process.emit('nodectl:restart', act, abs, null);
                }
              }, NC.OPTIONS.delay);
            }
          });
        };
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          dir = _ref2[_i];
          timeout = null;
          _fn(dir);
        }
      }
      if (NC.OPTIONS.assets && NC.OPTIONS.output) {
        _ref3 = [NC.OPTIONS.assets].concat(seekdir(NC.OPTIONS.assets));
        _fn1 = function(dir) {
          var compile, out;
          out = dir.replace(NC.OPTIONS.assets, NC.OPTIONS.output);
          console.log('Master watch assets', '<', dir);
          compile = function(act, rel) {
            var abs, dst;
            if (/\.(js|coffee|css|styl|html|jade)$/.test(rel)) {
              abs = path.join(dir, rel);
              dst = (function() {
                switch (path.extname(rel)) {
                  case '.coffee':
                    return path.join(out, rel.replace(/\.coffee$/, '.js'));
                  case '.styl':
                    return path.join(out, rel.replace(/\.styl$/, '.css'));
                  case '.jade':
                    return path.join(out, rel.replace(/\.jade$/, '.html'));
                  default:
                    return path.join(out, rel);
                }
              })();
              if (fs.existsSync(abs)) {
                return process.emit('nodectl:rebuild', abs, dst);
              } else {
                return fs.unlinkSync(dst);
              }
            }
          };
          fs.watch(dir, compile);
          return setTimeout(function() {
            var rel, _k, _len2, _ref4, _results;
            _ref4 = fs.readdirSync(dir);
            _results = [];
            for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
              rel = _ref4[_k];
              _results.push(compile(null, rel));
            }
            return _results;
          }, 500);
        };
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          dir = _ref3[_j];
          timeout = null;
          _fn1(dir);
        }
      }
      return (function() {
        var i, worker, _k, _ref4;
        for (i = _k = 0, _ref4 = NC.OPTIONS.cluster; 0 <= _ref4 ? _k < _ref4 : _k > _ref4; i = 0 <= _ref4 ? ++_k : --_k) {
          worker = cluster.fork({
            __nodectl: "worker." + (i + 1)
          });
          worker.type = "worker." + (i + 1);
          NC.PROCESS.wid.push(worker.process.pid);
        }
        return NC.EXPORTS();
      })();
    } else {
      process.on('SIGINT', function() {
        console.debug('Worker trap SIGINT');
        process.suicide = true;
        return process.exit(0);
      });
      return require(path.join(NC.ROOTDIR, NC.PROJECT.main));
    }
  }
})();
